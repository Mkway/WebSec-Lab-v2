// 취약점별 결과 렌더링 모듈
class VulnerabilityRenderer {

    // SQL Injection 결과 렌더링
    static renderSQLInjection(result) {
        const { data, mode, language, requestData } = result;
        const server = SERVERS[language];
        const isVulnerable = mode === 'vulnerable';

        // 공격 성공 여부 판단
        const attackSuccess = data?.result?.authentication_bypassed ||
                             data?.data?.attack_success ||
                             data?.success === true;

        return `
            <div class="vulnerability-section">
                <h4>💉 SQL Injection 분석</h4>

                ${isVulnerable && attackSuccess ? `
                    <div class="alert alert-danger">
                        <strong>⚠️ 인증 우회 성공!</strong> SQL 인젝션으로 로그인을 우회했습니다.
                    </div>
                ` : ''}

                <div class="vulnerability-principles">
                    <h5>🔍 취약점 원리</h5>
                    <div class="principle-explanation">
                        <p><strong>SQL Injection</strong>은 사용자 입력을 SQL 쿼리에 직접 삽입할 때 발생하는 취약점입니다.</p>
                        <p>공격자가 악성 SQL 코드를 삽입하여 데이터베이스를 비인가된 방법으로 조작할 수 있습니다.</p>
                    </div>
                </div>

                <div class="code-section">
                    <h5>📝 취약한 코드 예시</h5>
                    <pre><code class="language-sql">-- 취약한 쿼리 (사용자 입력 직접 삽입)
SELECT * FROM users
WHERE username = '${requestData.username}'
  AND password = '${requestData.password}'

-- 실제 실행된 쿼리 (인젝션 적용됨)
SELECT * FROM users
WHERE username = 'admin' OR '1'='1'
  AND password = '' OR '1'='1'</code></pre>
                </div>

                <div class="analysis-section">
                    <h5>🔍 취약점 분석</h5>
                    <ul>
                        <li><strong>원인:</strong> 사용자 입력을 SQL 쿼리에 직접 삽입</li>
                        <li><strong>공격 벡터:</strong> OR 조건으로 인증 우회</li>
                        <li><strong>위험도:</strong> 높음 (데이터베이스 전체 접근 가능)</li>
                    </ul>
                </div>

                <div class="mitigation-section">
                    <h5>🛡️ 보안 대책</h5>
                    <pre><code class="language-php">// 안전한 코드 (Prepared Statement)
$stmt = $pdo->prepare("SELECT * FROM users WHERE username = ? AND password = ?");
$stmt->execute([$username, $password]);</code></pre>
                </div>
            </div>
        `;
    }

    // XSS 결과 렌더링
    static renderXSS(result) {
        const { data, mode, language, requestData } = result;
        const server = SERVERS[language];
        const isVulnerable = mode === 'vulnerable';

        const xssDetected = data?.result?.xss_detected;
        const htmlOutput = data?.result?.html_output;
        const riskLevel = data?.analysis?.risk_level || 'medium';

        return `
            <div class="vulnerability-section">
                <h4>🔥 Cross-Site Scripting (XSS) 분석</h4>

                ${isVulnerable && xssDetected ? `
                    <div class="alert alert-danger">
                        <strong>⚠️ XSS 취약점 발견!</strong> 악성 스크립트가 실행될 수 있습니다.
                    </div>
                ` : ''}

                <div class="vulnerability-principles">
                    <h5>🔍 취약점 원리</h5>
                    <div class="principle-explanation">
                        <p><strong>Cross-Site Scripting (XSS)</strong>는 웹 애플리케이션에서 사용자 입력을 제대로 검증하지 않아 발생하는 취약점입니다.</p>
                        <p>사용자가 입력한 데이터가 브라우저에서 스크립트로 실행되어 쿠키 탈취, 세션 하이재킹, 사이트 도용 등의 공격이 가능합니다.</p>
                    </div>
                </div>

                ${isVulnerable && htmlOutput ? `
                    <div class="xss-preview">
                        <h5>🎯 XSS 실행 결과</h5>
                        <div class="xss-demo-container">
                            <div class="demo-label">서버에서 처리된 결과:</div>
                            <div class="xss-output">${htmlOutput}</div>
                            <div class="xss-live-demo">
                                <strong>⚠️ 실제 XSS 실행:</strong>
                                <div class="xss-execution-area">
                                    ${VulnerabilityRenderer.autoExecuteXSS(htmlOutput, requestData.payload)}
                                </div>
                            </div>
                        </div>
                    </div>
                ` : ''}

                <div class="code-section">
                    <h5>📝 취약한 코드 예시</h5>
                    <pre><code class="language-php">// 취약한 코드 (입력값 직접 출력)
echo "<div>사용자 입력: " . $_POST['search'] . "</div>";

// 사용자가 입력한 값: ${requestData.payload}
// 결과: ${htmlOutput}</code></pre>
                </div>

                <div class="analysis-section">
                    <h5>🔍 페이로드 분석</h5>
                    ${this.renderPayloadAnalysis(data?.analysis?.payload_analysis)}
                </div>

                <div class="mitigation-section">
                    <h5>🛡️ 보안 대책</h5>
                    <pre><code class="language-php">// 안전한 코드 (HTML 이스케이프)
echo "<div>사용자 입력: " . htmlspecialchars($_POST['search'], ENT_QUOTES, 'UTF-8') . "</div>";

// 또는 템플릿 엔진 사용
echo $twig->render('search.html', ['query' => $search]);</code></pre>
                </div>

                <div class="recommendations-section">
                    <h5>💡 권장사항</h5>
                    ${this.renderRecommendations(data?.analysis?.recommendations)}
                </div>
            </div>
        `;
    }

    // 페이로드 분석 렌더링
    static renderPayloadAnalysis(analysis) {
        if (!analysis) return '<p>분석 데이터 없음</p>';

        return `
            <div class="payload-analysis">
                <div class="analysis-grid">
                    <div class="analysis-item">
                        <span class="label">페이로드 길이:</span>
                        <span class="value">${analysis.length} 문자</span>
                    </div>
                    <div class="analysis-item">
                        <span class="label">스크립트 태그:</span>
                        <span class="value ${analysis.contains_script_tags ? 'danger' : 'safe'}">
                            ${analysis.contains_script_tags ? '⚠️ 포함' : '✅ 없음'}
                        </span>
                    </div>
                    <div class="analysis-item">
                        <span class="label">이벤트 핸들러:</span>
                        <span class="value">${analysis.contains_event_handlers} 개</span>
                    </div>
                    <div class="analysis-item">
                        <span class="label">인코딩 상태:</span>
                        <span class="value">
                            ${analysis.encoding_detected?.url_encoded ? 'URL 인코딩 ' : ''}
                            ${analysis.encoding_detected?.html_entities ? 'HTML 엔티티 ' : ''}
                            ${!analysis.encoding_detected?.url_encoded && !analysis.encoding_detected?.html_entities ? '인코딩 없음' : ''}
                        </span>
                    </div>
                </div>
            </div>
        `;
    }

    // 권장사항 렌더링
    static renderRecommendations(recommendations) {
        if (!recommendations) return '<p>권장사항 없음</p>';

        return `
            <ul class="recommendations-list">
                <li><strong>입력 검증:</strong> ${recommendations.input_validation}</li>
                <li><strong>출력 인코딩:</strong> ${recommendations.output_encoding}</li>
                <li><strong>CSP 헤더:</strong> ${recommendations.csp_headers}</li>
                <li><strong>보안 프레임워크:</strong> ${recommendations.secure_frameworks}</li>
            </ul>
        `;
    }

    // XSS 자동 실행 (Vue 버전과 동일)
    static autoExecuteXSS(htmlOutput, payload) {
        try {
            // XSS 공격 성공 여부 감지
            const hasScript = htmlOutput.includes('<script>') || htmlOutput.includes('javascript:') ||
                             htmlOutput.includes('onerror=') || htmlOutput.includes('onload=');
            const isVulnerable = hasScript && htmlOutput.includes(payload);

            if (isVulnerable) {
                // 실제 XSS 실행
                setTimeout(() => {
                    executeXSSScript(htmlOutput);
                }, 500);

                return `
                    <div class="alert alert-success mb-3">
                        <i class="fas fa-check-circle"></i>
                        <strong>✅ XSS 공격 실행됨!</strong>
                        JavaScript alert가 실행되었습니다.
                    </div>
                    ${htmlOutput}
                `;
            } else {
                return htmlOutput;
            }
        } catch (error) {
            console.error('XSS 자동 실행 오류:', error);
            return htmlOutput;
        }
    }


    // 메인 렌더링 함수
    static render(result) {
        const { vulnerability } = result;

        switch (vulnerability) {
            case 'sql-injection':
                return this.renderSQLInjection(result);
            case 'xss':
                return this.renderXSS(result);
            default:
                return `<div>알 수 없는 취약점 유형: ${vulnerability}</div>`;
        }
    }
}

// XSS 데모 실행 함수 (전역) - Vue 버전과 동일한 방식으로 실제 실행
function executeXSSDemo(payload, targetId) {
    const targetElement = document.getElementById(targetId);
    if (targetElement) {
        targetElement.innerHTML = '';

        try {
            // 실제 XSS 실행 - Vue 버전과 동일한 방식
            executeXSSScript(payload);

            // 실행 결과 표시
            targetElement.innerHTML = `
                <div class="xss-execution-result">
                    <div class="xss-success">✅ XSS 공격 성공!</div>
                    <div class="xss-effect">실제 JavaScript 코드가 실행되었습니다!</div>
                    <div class="xss-demo-html">${payload}</div>
                </div>
            `;
        } catch (error) {
            console.error('XSS 실행 오류:', error);
            targetElement.innerHTML = `
                <div class="xss-execution-result">
                    <div class="xss-error">XSS 실행 중 오류: ${error.message}</div>
                </div>
            `;
        }
    }
}

// XSS 스크립트 실제 실행 (Vue 버전에서 가져옴)
function executeXSSScript(content) {
    try {
        // <script> 태그 내용 추출
        const scriptMatch = content.match(/<script[^>]*>(.*?)<\/script>/gi);
        if (scriptMatch) {
            scriptMatch.forEach(scriptTag => {
                const scriptContent = scriptTag.replace(/<script[^>]*>|<\/script>/gi, '');
                if (scriptContent.trim()) {
                    eval(scriptContent);
                }
            });
        }

        // 인라인 이벤트 핸들러 처리 (onerror, onload 등)
        const eventMatches = content.match(/on\w+\s*=\s*['"](.*?)['"]/gi);
        if (eventMatches) {
            eventMatches.forEach(eventHandler => {
                const jsCode = eventHandler.replace(/on\w+\s*=\s*['"]|['"]/gi, '');
                if (jsCode.trim()) {
                    eval(jsCode);
                }
            });
        }

        // javascript: 프로토콜 처리
        const jsProtocolMatch = content.match(/javascript:\s*(.*?)(?=['"\s>])/gi);
        if (jsProtocolMatch) {
            jsProtocolMatch.forEach(jsCode => {
                const code = jsCode.replace(/javascript:\s*/i, '');
                if (code.trim()) {
                    eval(code);
                }
            });
        }
    } catch (error) {
        console.log('XSS 실행 중 오류:', error.message);
        // 에러가 발생해도 일반적인 alert는 실행
        if (content.includes('alert')) {
            const alertMatch = content.match(/alert\s*\(\s*['"`](.*?)['"`]\s*\)/);
            if (alertMatch) {
                alert(`XSS 공격 성공: ${alertMatch[1]}`);
            } else {
                alert('XSS 공격이 성공했습니다!');
            }
        }
    }
}

// XSS 알림 시뮬레이션
function showXSSAlert(scriptContent) {
    // 실제 alert 대신 모달로 표시
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
    `;

    modal.innerHTML = `
        <div style="
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 400px;
        ">
            <h3 style="color: #dc3545; margin-bottom: 15px;">🚨 XSS 공격 시뮬레이션</h3>
            <p style="margin-bottom: 15px;">실제 공격에서는 다음 코드가 실행됩니다:</p>
            <code style="background: #f8f9fa; padding: 10px; border-radius: 4px; display: block; margin: 10px 0;">${scriptContent}</code>
            <button onclick="this.parentElement.parentElement.remove()" style="
                background: #dc3545;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
            ">닫기</button>
        </div>
    `;

    document.body.appendChild(modal);

    // 3초 후 자동 제거
    setTimeout(() => {
        if (modal.parentElement) {
            modal.remove();
        }
    }, 5000);
}

// 이미지 오류 시뮬레이션
function simulateImageError() {
    showXSSAlert('alert("XSS by image error!")');
}