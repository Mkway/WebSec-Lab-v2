<?php

namespace WebSecLab\Controllers;

use WebSecLab\Vulnerabilities\SQLInjection;
use WebSecLab\Vulnerabilities\XSS\ReflectedXSS;
use WebSecLab\Controllers\XSSController;
use WebSecLab\Utils\ResponseFormatter;

/**
 * Vulnerability Controller
 * 취약점 테스트 요청을 처리하는 컨트롤러
 *
 * @OA\Tag(
 *     name="Vulnerabilities",
 *     description="Vulnerability testing endpoints"
 * )
 */
class VulnerabilityController extends BaseController
{
    private array $vulnerabilityClasses = [
        'sql-injection' => SQLInjection::class,
        'xss' => ReflectedXSS::class,
    ];

    /**
     * 사용 가능한 취약점 목록 반환
     *
     * @OA\Get(
     *     path="/vulnerabilities",
     *     tags={"Vulnerabilities"},
     *     summary="List Available Vulnerabilities",
     *     @OA\Response(
     *         response=200,
     *         description="List of supported vulnerability types",
     *         @OA\JsonContent(ref="#/components/schemas/VulnerabilityListResponse")
     *     )
     * )
     */
    public function listVulnerabilities(): string
    {
        return $this->successResponse([
            'vulnerabilities' => array_keys($this->vulnerabilityClasses),
            'total_count' => count($this->vulnerabilityClasses),
            'server_info' => [
                'language' => 'PHP',
                'version' => PHP_VERSION,
                'framework' => 'Custom MVC'
            ]
        ]);
    }

    /**
     * 취약점 테스트 실행
     *
     * @OA\Post(
     *     path="/vulnerabilities/{type}",
     *     tags={"Vulnerabilities"},
     *     summary="Execute Vulnerability Test",
     *     @OA\Parameter(
     *         name="type",
     *         in="path",
     *         required=true,
     *         description="Type of vulnerability to test",
     *         @OA\Schema(type="string", enum={"sql-injection", "xss", "command-injection"})
     *     ),
     *     @OA\RequestBody(
     *         required=true,
     *         @OA\JsonContent(
     *             @OA\Property(property="mode", type="string", enum={"vulnerable", "safe"}, default="vulnerable"),
     *             @OA\Property(property="payload", type="string"),
     *             @OA\Property(property="parameters", type="object")
     *         )
     *     ),
     *     @OA\Response(
     *         response=200,
     *         description="Vulnerability test result",
     *         @OA\JsonContent(ref="#/components/schemas/VulnerabilityResult")
     *     )
     * )
     */
    public function executeVulnerabilityTest(string $vulnerabilityType, array $input): string
    {
        try {
            // XSS는 전용 컨트롤러로 리다이렉트
            if ($vulnerabilityType === 'xss') {
                $xssController = new XSSController();
                return $xssController->testReflectedXSS();
            }

            // 기본 입력값 검증
            $this->validateInput($input, ['payload', 'mode']);

            $payload = $input['payload'];
            $mode = $input['mode']; // 'vulnerable' or 'safe'
            $parameters = $input['parameters'] ?? [];

            // 모드 검증
            if (!in_array($mode, ['vulnerable', 'safe'])) {
                throw new \InvalidArgumentException('Mode must be either "vulnerable" or "safe"');
            }
            
            // 취약점 클래스 확인
            if (!isset($this->vulnerabilityClasses[$vulnerabilityType])) {
                throw new \InvalidArgumentException("Vulnerability type '{$vulnerabilityType}' not supported");
            }
            
            $vulnerabilityClass = $this->vulnerabilityClasses[$vulnerabilityType];
            $vulnerabilityInstance = new $vulnerabilityClass();
            
            // 실행 시간 측정과 함께 테스트 실행
            $executionData = $this->measureExecutionTime(function() use ($vulnerabilityInstance, $payload, $mode, $parameters) {
                if ($mode === 'vulnerable') {
                    return $vulnerabilityInstance->executeVulnerableCode($payload, $parameters);
                } else {
                    return $vulnerabilityInstance->executeSafeCode($payload, $parameters);
                }
            });
            
            $result = $executionData['result'];
            $executionTime = $executionData['execution_time'];
            
            // 분석 정보 생성
            $analysis = $this->generateAnalysis($vulnerabilityType, $mode, $result);
            
            // 로그 기록
            $this->log('INFO', "Vulnerability test executed", [
                'type' => $vulnerabilityType,
                'mode' => $mode,
                'payload_length' => strlen($payload),
                'execution_time' => $executionTime
            ]);
            
            return $this->vulnerabilityResponse(
                $vulnerabilityType,
                $payload,
                $mode,
                array_merge($result, ['execution_time' => $executionTime]),
                $analysis
            );
            
        } catch (\InvalidArgumentException $e) {
            return $this->errorResponse($e->getMessage(), 400);
        } catch (\Exception $e) {
            $this->log('ERROR', "Vulnerability test failed", [
                'type' => $vulnerabilityType ?? 'unknown',
                'error' => $e->getMessage()
            ]);
            return $this->errorResponse('Test execution failed: ' . $e->getMessage(), 500);
        }
    }

    /**
     * 테스트 결과 분석 정보 생성
     */
    private function generateAnalysis(string $vulnerabilityType, string $mode, array $result): array
    {
        $analysis = [
            'risk_level' => $mode === 'vulnerable' ? 'high' : 'none',
            'mode_description' => $mode === 'vulnerable' 
                ? 'Vulnerable code executed - security controls bypassed'
                : 'Safe code executed - security controls active',
            'timestamp' => date('c')
        ];

        // 취약점별 특화 분석
        switch ($vulnerabilityType) {
            case 'sql-injection':
                $analysis['attack_type'] = 'Database manipulation';
                $analysis['impact'] = $mode === 'vulnerable' 
                    ? 'Potential unauthorized data access, modification, or deletion'
                    : 'Query safely parameterized - no injection possible';
                break;
                
            case 'xss':
                $analysis['attack_type'] = 'Client-side code injection';
                $analysis['impact'] = $mode === 'vulnerable'
                    ? 'Potential session hijacking, defacement, or malicious redirects'
                    : 'Input properly escaped - no script execution possible';
                break;
                
            case 'command-injection':
                $analysis['attack_type'] = 'Server-side command execution';
                $analysis['impact'] = $mode === 'vulnerable'
                    ? 'Potential full server compromise and data breach'
                    : 'Input properly validated - no command execution possible';
                break;
        }

        return $analysis;
    }
}